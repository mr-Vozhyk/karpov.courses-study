1) Начнем с простого вопроса: что произойдет в результате выполнения следующей команды?
import pandas as pnds

2) Теперь поработаем с данными о поездках на такси в Нью-Йорке, где также имеется информация о погодных условиях и выходных днях.  
pickup_dt – период с точностью до часа
pickup_month – месяц
borough – район Нью-Йорка, из которого был сделан заказ (5 районов + аэропорт)
pickups – число поездок за период (час)
hday – является ли день праздничным/выходным; Y - да,  N - нет
spd – скорость ветра в милях в час
vsb – видимость
temp – температура в градусах Фаренгейта
dewp – точка росы по Фаренгейту
slp – давление
pcp_01 – количество осадков за час
pcp_06 – количество осадков за 6 часов
pcp_24 – количество осадков за 24 часа
sd – глубина снега в дюймах
Импортируйте библиотеку pandas, а затем загрузите датасет 2_taxi_nyc (находится в папке). Результат сохраните в переменную taxi.
Для загрузки датасэта в pandas по ссылке просто выполните pd.read_csv('path')

3) Проверьте, сколько всего строк и столбцов имеется в датасете.

4) Давайте посмотрим на типы колонок. Все ли из них считались правильно? Назовите тип, преобладающий в датасете.

5) В названиях столбцов pcp 01, pcp 06, pcp 24 встречается пробел. Это не очень удобно, если в дальнейшем вы планируете обращаться к колонкам через точку, без использования кавычек и скобочек. 
Замените пробел в названиях на знак нижнего подчеркивания. 

6) Вас попросили узнать, сколько записей (строк) в датафрейме относятся к району Манхэттен (Manhattan). Получить ответ на данный вопрос можно было бы, например, с помощью следующей команды:
taxi.query("borough == 'Manhattan'").shape[0]
А если мы хотим посмотреть, сколько раз встречается каждый из районов? Неужели придется использовать подобную конструкцию для каждого уровня переменной? Здесь на помощь приходит метод value_counts(), подробнее о котором можно почитать в конспекте! 
Сколько раз в данных встречается район Бруклин (Brooklyn)?

7) Следующая задача: выяснить, из какого района было совершено наибольшее количество поездок за весь период. 
Для начала, посчитайте общее количество поездок (pickups), без группировки.

8) А теперь сгруппируйте данные по району (borough) и укажите, из какого пункта было совершено больше всего поездок.

9) ⭐️Задание со звёздочкой!⭐️
Еще несколько полезных методов в pandas! Возможно, в предыдущем степе вы просто посмотрели на данные или отсортировали значения. Ускорить данный процесс в дальнейшем помогут методы idxmin() и idxmax(), которые возвращают индекс минимального или максимального значения.
Сохраните название района с наименьшим числом поездок в переменную min_pickups, применив подходящий метод.

10) Продолжим изучение данных и посмотрим на число поездок в выходные дни. Сгруппируйте данные по двум признакам: району города и является ли день выходным (колонки borough и hday). Сравните среднее число поездок, и назовите районы, из которых по праздникам в среднем поступает больше заказов, чем в обычные дни. 

11) Для каждого района посчитайте число поездок по месяцам. Отсортируйте полученные значения по убыванию и сохраните результирующий датафрейм в pickups_by_mon_bor. Обратите внимание, что итоговый датасет должен состоять из 3-х колонок – pickup_month, borough, pickups.

12) 💀 Сложное задание! 💀
Теперь задача посложнее! Попрактикуемся в написании собственных функций и их применении к датафрейму. Поскольку данные о поездках в Нью-Йорке, температура представлена в градусах Фаренгейта. 
Напишите функцию temp_to_celcius, которая получает на вход колонку с температурой в °F, и возвращает значения, переведенные в градусы Цельсия.
Формула:

Celsius = ((Fahrenheit-32) *5.0)/(9.0)
 ​	
Пример работы:
> taxi['temp'][:5]
0    30.0
1    30.0
3    30.0
4    30.0
5    30.0

> taxi['temp_C'] = temp_to_celcius(taxi['temp'])
> taxi['temp_C'][:5]
0   -1.111111
1   -1.111111
3   -1.111111
4   -1.111111
5   -1.111111